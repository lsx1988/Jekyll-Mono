---
layout: post
title: KMP学习总结与实现
author: Shixun Liu
---

本人是算法小白，在网上看了好多相关的博客，在这里总结一些自己对KMP的理解，并用Java将其实现

## 要解决什么问题？
-----
存在一个字符串S，我们假定它的内容是‘abcd abca bcae'，此时还存在另一个字符串P，假定其为’bca‘。某些时候，我们希望知道字符串S当中是否包含字符串P，以及P第一次出现在S中时所在的索引位置（索引以字符串P的第一个字符出现在字符串S中的位置为准）。在本例中，字符串S很明显包含字符串P，且P第一次出现的位置为6。若S中不包含P，则默认索引值为-1。

## 暴力搜索
----
解决该问题最直接，也是最容易想到的方法就是对S和P进行暴力搜索。将两个字符串从头对齐，一个一个字符的去匹配，一旦发现两个字符不匹配，则将字符串P向后挪动一位，而后再从头开始一个一个判断重新对应的字符是否相同，直到P能够完全匹配或者判定P不在S中。Java实现如下： 

```java
pubilc void bruteForce(String s, Stirng p){
	int sLength = source.length();
	int tLength = target.length();
	int i = 0;
	int j = 0;
	while (i <= Math.max(sLength,tLength) - 1 && j <= tLength - 1){
	    if (source.charAt(i) == target.charAt(j)){
	        i++;
	        j++;
	    } else {
	        i = i - j + 1;
	        j = 0;
	    }
	}
	if (j == tLength){
	    return i - j;
	} else {
	    return -1;
	}
}
```

该算法的一大问题就是复杂度过高，特别是当出现如下极端的情况时，比如S=’aaaaaaa',P='aab'时，复杂度则为O(mn)


