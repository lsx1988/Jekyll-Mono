---
layout: post
title: KMP学习总结与实现
author: 大饼
---

本人是算法小白，在网上看了好多相关的博客，在这里总结一些自己对KMP的理解，并用Java将其实现。这也是我的第一篇博客，如果哪里写的有问题，还请大家见谅并指正。  
内容参考于：  
[The Knuth-Morris-Pratt Algorithm in my own words](http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/) （必读）   
[【经典算法】——KMP，深入讲解next数组的求解](http://www.cnblogs.com/c-cloud/p/3224788.html) 

# 要解决什么问题？
-----
存在一个字符串S，我们假定它的内容是‘abcd abca bcae'，此时还存在另一个字符串P，假定其为’bca‘。某些时候，我们希望知道字符串S当中是否包含字符串P，以及P第一次出现在S中时所在的索引位置（以字符串P的第一个字符出现在字符串S中的位置为准）。在本例中，字符串S很明显包含字符串P，且P第一次出现的位置为6。若S中不包含P，则默认索引值为-1。

# 暴力搜索
----
解决该问题最直接，也是最容易想到的方法就是对S和P进行暴力搜索。将两个字符串从头对齐，一个一个字符的去匹配，一旦发现两个字符不匹配，则将字符串P向后挪动一位，而后再从头开始一个一个判断重新对应的字符是否相同，直到P能够完全匹配或者判定P不在S中。Java实现如下： 

```java
//这里默认字符串str与pattern不为空，且str的长度大于等于pattern
pubilc void bruteForce(String str, Stirng pattern){

	int sLength = str.length(); //获取字符串长度
	int tLength = pattern.length();//获取pattern长度
	int i = 0;//str的索引
	int j = 0;//pattern的索引
	
	while (i <= sLength - 1 && j <= tLength - 1){
		//从头开始遍历每一个字符，当字符相等时，向后移动至下个字符
	    if (str.charAt(i) == pattern.charAt(j)){
	        i++;
	        j++;
	    } else {
	    	 //如果一旦字符串不匹配，str的索引回溯至上个匹配起始点的下一位，相当于把整个pattern后移一位
	        i = i - j + 1; 
	        //pattern的索引归零，从头开始
	        j = 0; 
	    }
	}
	
	// 如果能够遍历整个pattern，说明在str中能够找到pattern
	if (j == tLength){
	    return i - j;
	} else {
	    return -1;
	}
}
```
暴力搜索的主要问题就是效率较低，复杂度为O(mn)。因此引入了KMP方法，以提高算法效率，尽快完成字符串的检索。

#KMP
----
有关KMP的背景与来源这里就不做介绍了，首先介绍KMP中的一个重要概念，既”部分匹配表“（Partial Match Table）。  
这里我们假设字符串为”bacbababaabcbab“，搜索词为”abababca“  
###部分匹配表
首先该表是专门为搜索词建立的，这里我们可以得到的部分匹配表如下，其中的value就是我们要获得的值： 

```
index  : 0 1 2 3 4 5 6 7
pattern: a b a b a b c a
value  : 0 0 1 2 3 4 0 1
```
这些值是怎么获得的呢？这里涉及到两个概念：前缀（prefixes) 和 后缀(suffixes) 
 
**前缀**  
一个字符串（忽略最后一个字符），始终以第一个字符为起点，由连续字符组成的子字符串，就是个字符串的前缀。仍以上面的搜索词为例，它的前缀有：
  
```
a
ab
aba
abab
ababa
ababab
abababc
```
**后缀**  
与前缀的定义相反，后缀就是一个字符串(忽略第一个字符), 始终以最后一个字符做结尾，由连续字符组成的子字符串：  

```
a
ca
bca
abca
babca
ababca
bababca
```
在了解了前缀和后缀的定义以后，我们定义部分匹配表中的value就是一个字符串中，最长的相同前缀和后缀的长度值。比如上面的例子中，只有一个相同前缀与后缀，就是’a'，则value = 1。再比如字符串‘ababa'，其前缀和后缀分别为：  

```
前缀：
a
ab
aba
abab

后缀：
a
ba
aba
baba
```
其最长的相同前缀和后缀为’aba'，则该字符串对应的value为3。  

这时我们回到在开头举例的部分匹配表，每一个value对应的值就是子字符串pattern[0,index]对应的value。比如在index = 3处，对应的子字符串为‘abab'，其相同前缀和后缀的最大长度值为2。这里贴出计算一个字符串部分匹配表的Java代码:

```java
public static int[] matchTable(String pattern){
		int pLength = pattern.length();
		int[] table = new int[pLength];
		table[0] = 0; //第一个字符对应的值为0
		for(int i = 1; i <= pLength - 1; i++){
			if(pattern.charAt(i) == pattern.charAt(table[i-1])){
				table[i] = table[i-1] + 1;
			}else{
				table[i] = 0;
			}
		}
		return table;
	}
```
这段代码的第6行可能不好理解



###加速检索原理

现在我们已经知道了部分匹配表是这样构建的，接下来看看是怎样利用该表来加速字符串匹配的，一下我对加速原理的理解


